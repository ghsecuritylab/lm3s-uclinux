From 4eac9f507672d4e7ccf454b22076908d039f917e Mon Sep 17 00:00:00 2001
From: Max Neklyudov <macscomp@gmail.com>
Date: Mon, 6 May 2013 15:58:46 +0400
Subject: [PATCH] Fix thumb2

diff --git a/ldso/ldso/arm/dl-startup.h b/ldso/ldso/arm/dl-startup.h
index f7d6052..b05ac76 100644
--- a/ldso/ldso/arm/dl-startup.h
+++ b/ldso/ldso/arm/dl-startup.h
@@ -7,7 +7,7 @@
  */
 
 #include <features.h>
-#include <bits/arm_asm.h>
+#include <bits/arm_bx.h> 
 
 #if !defined(__thumb__)
 __asm__(
diff --git a/ldso/ldso/arm/resolve.S b/ldso/ldso/arm/resolve.S
index 08889d0..d294fda 100644
--- a/ldso/ldso/arm/resolve.S
+++ b/ldso/ldso/arm/resolve.S
@@ -92,6 +92,7 @@
 
 #include <sys/syscall.h>
 #include <bits/arm_asm.h>
+#include <bits/arm_bx.h> 
 
 #include <features.h>
 
diff --git a/libc/string/arm/_memcpy.S b/libc/string/arm/_memcpy.S
index b26080d..e680650 100644
--- a/libc/string/arm/_memcpy.S
+++ b/libc/string/arm/_memcpy.S
@@ -40,6 +40,7 @@
 #include <features.h>
 #include <endian.h>
 #include <bits/arm_asm.h>
+#include <bits/arm_bx.h> 
 
 #if !defined(THUMB1_ONLY)
 /*
diff --git a/libc/string/arm/memcmp.S b/libc/string/arm/memcmp.S
index 65409f4..ac13b0d 100644
--- a/libc/string/arm/memcmp.S
+++ b/libc/string/arm/memcmp.S
@@ -31,6 +31,7 @@
 
 #include <features.h>
 #include <bits/arm_asm.h>
+#include <bits/arm_bx.h> 
 
 .text
 .global memcmp
diff --git a/libc/string/arm/memset.S b/libc/string/arm/memset.S
index 66aa603..37baaa1 100644
--- a/libc/string/arm/memset.S
+++ b/libc/string/arm/memset.S
@@ -20,6 +20,7 @@
 #include <features.h>
 #include <sys/syscall.h>
 #include <bits/arm_asm.h>
+#include <bits/arm_bx.h> 
 
 .text
 .global memset
diff --git a/libc/string/arm/strcmp.S b/libc/string/arm/strcmp.S
index 97363c1..4ea0d58 100644
--- a/libc/string/arm/strcmp.S
+++ b/libc/string/arm/strcmp.S
@@ -31,6 +31,7 @@
 
 #include <features.h>
 #include <bits/arm_asm.h>
+#include <bits/arm_bx.h> 
 
 .text
 .global strcmp
diff --git a/libc/string/arm/strlen.S b/libc/string/arm/strlen.S
index 949e918..a56f0a2 100644
--- a/libc/string/arm/strlen.S
+++ b/libc/string/arm/strlen.S
@@ -21,6 +21,7 @@
 #include <endian.h>
 #include <sys/syscall.h>
 #include <bits/arm_asm.h>
+#include <bits/arm_bx.h> 
 
 /* size_t strlen(const char *S)
  * entry: r0 -> string
diff --git a/libc/sysdeps/linux/arm/__longjmp.S b/libc/sysdeps/linux/arm/__longjmp.S
index 5faf4ec..3f5785c 100644
--- a/libc/sysdeps/linux/arm/__longjmp.S
+++ b/libc/sysdeps/linux/arm/__longjmp.S
@@ -19,6 +19,7 @@
 
 #include <features.h>
 #include <bits/arm_asm.h>
+#include <bits/arm_bx.h>
 #define _SETJMP_H
 #define _ASM
 #include <bits/setjmp.h>
diff --git a/libc/sysdeps/linux/arm/bits/arm_asm.h b/libc/sysdeps/linux/arm/bits/arm_asm.h
index 921c9a3..ff8ea92 100644
--- a/libc/sysdeps/linux/arm/bits/arm_asm.h
+++ b/libc/sysdeps/linux/arm/bits/arm_asm.h
@@ -24,12 +24,4 @@
 #define THUMB1_ONLY 1
 #endif
 
-#if defined(__USE_BX__)
-# if (   defined (__ARM_ARCH_2__)  || defined (__ARM_ARCH_3__) \
-      || defined (__ARM_ARCH_3M__) || defined (__ARM_ARCH_4__) \
-     )
-#  error Use of BX was requested, but is not available on the target processor.
-# endif /* ARCH level */
-#endif /* __USE_BX__ */
-
 #endif /* _ARM_ASM_H */
diff --git a/libc/sysdeps/linux/arm/bits/arm_bx.h b/libc/sysdeps/linux/arm/bits/arm_bx.h
new file mode 100644
index 0000000..5a2bdf6
--- /dev/null
+++ b/libc/sysdeps/linux/arm/bits/arm_bx.h
@@ -0,0 +1,34 @@
+/* Copyright (C) 2013 Yann E. MORIN <[hidden email]> 
+ * 
+ * This file is free software; you can redistribute it and/or modify 
+ * it under the terms of the GNU Lesser General Public License as 
+ * published by the Free Software Foundation; either version 2.1 of 
+ * the License, or (at your option) any later version. 
+ * 
+ * This file is distributed in the hope that it will be useful, but 
+ * WITHOUT ANY WARRANTY; without even the implied warranty of 
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+ * Lesser General Public License for more details. 
+ * 
+ * You should have received a copy of the GNU Lesser General Public 
+ * License along with the GNU C Library; if not, see 
+ * <http://www.gnu.org/licenses/>. 
+ */ 
+ 
+#ifndef _ARM_BX_H 
+#define _ARM_BX_H 
+ 
+/* We need features.h first */ 
+#if !defined _FEATURES_H 
+#error Please include features.h first 
+#endif /* features.h not yet included */ 
+ 
+#if defined(__USE_BX__) 
+# if (   defined (__ARM_ARCH_2__)  || defined (__ARM_ARCH_3__) \ 
+      || defined (__ARM_ARCH_3M__) || defined (__ARM_ARCH_4__) \ 
+     ) 
+#  error Use of BX was requested, but is not available on the target processor. 
+# endif /* ARCH level */ 
+#endif /* __USE_BX__ */ 
+ 
+#endif /* _ARM_BX_H */ 
diff --git a/libc/sysdeps/linux/arm/clone.S b/libc/sysdeps/linux/arm/clone.S
index fdc05b8..0807168 100644
--- a/libc/sysdeps/linux/arm/clone.S
+++ b/libc/sysdeps/linux/arm/clone.S
@@ -25,6 +25,7 @@
 #include <bits/errno.h>
 #include <sys/syscall.h>
 #include <bits/arm_asm.h>
+#include <bits/arm_bx.h> 
 
 #if defined(__NR_clone)
 /* int clone(int (*fn)(void *arg), void *child_stack, int flags, void *arg); */
@@ -112,8 +113,8 @@ __clone:
 	DO_CALL (clone)
 	movs	a1, a1
 	blt	__error
+	IT(tt, ne)
 	ldmnefd	sp!, {r4}
-	IT(t, ne)
 #if defined(__USE_BX__)
 	bxne	lr
 #else
--- a/libc/sysdeps/linux/arm/clone.S
+++ b/libc/sysdeps/linux/arm/clone.S
@@ -120,6 +120,7 @@
 #else
 	movne	pc, lr
 #endif
+	sub sp, sp, #4
 
 	@ pick the function arg and call address off the stack and execute
 	ldr	r0, [sp, #4]
diff --git a/libc/sysdeps/linux/arm/mmap64.S b/libc/sysdeps/linux/arm/mmap64.S
index 7071541..583f04b 100644
--- a/libc/sysdeps/linux/arm/mmap64.S
+++ b/libc/sysdeps/linux/arm/mmap64.S
@@ -21,6 +21,7 @@
 #include <bits/errno.h>
 #include <sys/syscall.h>
 #include <bits/arm_asm.h>
+#include <bits/arm_bx.h> 
 
 #if defined __UCLIBC_HAS_LFS__ && defined __NR_mmap2
 
diff --git a/libc/sysdeps/linux/arm/syscall-eabi.S b/libc/sysdeps/linux/arm/syscall-eabi.S
index b931882..82ac7ab 100644
--- a/libc/sysdeps/linux/arm/syscall-eabi.S
+++ b/libc/sysdeps/linux/arm/syscall-eabi.S
@@ -18,6 +18,7 @@
 
 #include <sys/syscall.h>
 #include <bits/arm_asm.h>
+#include <bits/arm_bx.h> 
 
 /* In the EABI syscall interface, we don't need a special syscall to
    implement syscall().  It won't work reliably with 64-bit arguments
diff --git a/libc/sysdeps/linux/arm/sysdep.h b/libc/sysdeps/linux/arm/sysdep.h
index e498695..e1b0d5d 100644
--- a/libc/sysdeps/linux/arm/sysdep.h
+++ b/libc/sysdeps/linux/arm/sysdep.h
@@ -21,7 +21,7 @@
 #define _LINUX_ARM_SYSDEP_H 1
 
 #include <common/sysdep.h>
-#include <bits/arm_asm.h>
+#include <bits/arm_bx.h> 
 
 #include <sys/syscall.h>
 /* For Linux we can use the system call table in the header file
diff --git a/libc/sysdeps/linux/arm/vfork.S b/libc/sysdeps/linux/arm/vfork.S
index 17d6a4d..9f8e7a5 100644
--- a/libc/sysdeps/linux/arm/vfork.S
+++ b/libc/sysdeps/linux/arm/vfork.S
@@ -7,6 +7,7 @@
 
 #include <features.h>
 #include <bits/arm_asm.h>
+#include <bits/arm_bx.h> 
 
 #define _ERRNO_H
 #include <bits/errno.h>

diff --git a/extra/Configs/Config.arm b/extra/Configs/Config.arm
index 0bb2971..5777d3b 100644
--- a/extra/Configs/Config.arm
+++ b/extra/Configs/Config.arm
@@ -36,3 +36,10 @@ config USE_BX
 	  Say 'y' to use BX to return from functions on your thumb-aware
 	  processor. Say 'y' if you need to use interworking. Say 'n' if not.
 	  It is safe to say 'y' even if you're not doing interworking.
+
+config USE_LDREXSTREX
+	bool "Use load-store exclusive ASM ops (not supported in SmartFusion)"
+	depends on COMPILE_IN_THUMB_MODE
+	default y
+	help
+	  Say 'y' to use LDREX/STREX ASM ops.
diff --git a/libpthread/linuxthreads.old/sysdeps/arm/pt-machine.h b/libpthread/linuxthreads.old/sysdeps/arm/pt-machine.h
index 583eb68..93804ba 100644
--- a/libpthread/linuxthreads.old/sysdeps/arm/pt-machine.h
+++ b/libpthread/linuxthreads.old/sysdeps/arm/pt-machine.h
@@ -22,12 +22,50 @@
 #ifndef _PT_MACHINE_H
 #define _PT_MACHINE_H   1
 
-#include <features.h>
+#include <sys/syscall.h>
+#include <unistd.h>
 
 #ifndef PT_EI
 # define PT_EI __extern_always_inline
 #endif
 
+#if defined(__thumb__)
+#if defined(__USE_LDREXSTREX__)
+PT_EI long int ldrex(int *spinlock)
+{
+	long int ret;
+	__asm__ __volatile__(
+		"ldrex %0, [%1]\n"
+		: "=r"(ret)
+		: "r"(spinlock) : "memory");
+	return ret;
+}
+
+PT_EI long int strex(int val, int *spinlock)
+{
+	long int ret;
+	__asm__ __volatile__(
+		"strex %0, %1, [%2]\n"
+		: "=r"(ret)
+		: "r" (val), "r"(spinlock) : "memory");
+	return ret;
+}
+
+/* Spinlock implementation; required.  */
+PT_EI long int
+testandset (int *spinlock)
+{
+  register unsigned int ret;
+
+  do {
+	  ret = ldrex(spinlock);
+  } while (strex(1, spinlock));
+
+  return ret;
+}
+
+#else /* __USE_LDREXSTREX__ */
+
 /* This will not work on ARM1 or ARM2 because SWP is lacking on those
    machines.  Unfortunately we have no way to detect this at compile
    time; let's hope nobody tries to use one.  */
@@ -37,8 +75,6 @@ PT_EI long int testandset (int *spinlock);
 PT_EI long int testandset (int *spinlock)
 {
   register unsigned int ret;
-
-#if defined(__thumb__)
   void *pc;
   __asm__ __volatile__(
 	".align 0\n"
@@ -51,15 +87,21 @@ PT_EI long int testandset (int *spinlock)
 	"\t.force_thumb"
 	: "=r"(ret), "=r"(pc)
 	: "0"(1), "r"(spinlock));
-#else
+  return ret;
+}
+#endif
+#else /* __thumb__ */
+
+PT_EI long int testandset (int *spinlock);
+PT_EI long int testandset (int *spinlock)
+{
+  register unsigned int ret;
   __asm__ __volatile__("swp %0, %1, [%2]"
 		       : "=r"(ret)
 		       : "0"(1), "r"(spinlock));
-#endif
-
   return ret;
 }
-
+#endif
 
 /* Get some notion of the current stack.  Need not be exactly the top
    of the stack, just something somewhere in the current frame.  */

-- 
1.8.1.2

